<!DOCTYPE html>
<html lang="en-us">

<head>
    <title>
Database Isolation Levels | The Dev Diary
</title>

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta name="generator" content="Hugo 0.110.0">


<link rel="canonical" href="https://thedevdiary.me/blog/database_isolation_levels/" >
<link href="/sass/main.min.246424037d4ce4c9ef4936a2bf7fb7d3317ebc6810bc67415c661f85231c98f0.css" rel="stylesheet">



</head>

<body>

    <div class="flexWrapper">
        <header class="headerWrapper">
    <div class="header">
        <div>
            <a href="https://thedevdiary.me/">
                <span class="terminal">dev@diary ~ $</span>
            </a>
        </div>
        <input class="side-menu" type="checkbox" id="side-menu">
        <label class="hamb" for="side-menu"><span class="hamb-line"></span></label>
        <nav class="headerLinks">
            <ul>
                
                <li>
                    <a href="https://thedevdiary.me/about" title="" >
                        ~/about</a>
                </li>
                
                <li>
                    <a href="https://thedevdiary.me/blog/" title="" >
                        ~/blog</a>
                </li>
                
                <li>
                    <a href="https://thedevdiary.me/bookshelf" title="" >
                        ~/bookshelf</a>
                </li>
                
            </ul>
        </nav>
    </div>
</header>


        <div class="content">
            <main class="main">
                
<div class="postWrapper">
    <h1>Database Isolation Levels</h1>
    <hr>
    
    <section class="postMetadata">
        <dl>
            
                
<dt>tags</dt>
<dd><span></span>
    <a href="/tags/database/">#database</a></dd>
            
            
            
            
                <dt>published</dt>
                
                <dd><time datetime="2019-03-05">March 5, 2019</time></dd>
            
            
        </dl>
    </section>
    
    <div class="postBody">
        <p>Hello, and welcome to my blog on database isolation levels. In this post, I will explain what database isolation levels are, why they are important, and how they affect the performance and correctness of concurrent transactions. I will also describe each of the four standard isolation levels defined by SQL, and discuss their pros and cons.</p>
<h3 id="what-is-database-isolation">What is database isolation?</h3>
<p>Database isolation refers to the ability of a database to allow a transaction to execute as if there are no other concurrently running transactions (even though in reality there can be a large number of concurrently running transactions). The overarching goal is to prevent anomalies that can occur as a result of inter-leaving transactions
and can possibly corrupt the database.</p>
<h3 id="what-are-database-isolation-levels">What are database isolation levels?</h3>
<p>Database isolation levels are used to define the level of isolation from other transactions that a transaction can achieve when accessing data. The more isolated a transaction is, the less likely it will interfere with other transactions operating on the same data at the same time.</p>
<p>Isolation is important because it ensures that transactions do not interfere with each other in an undesirable way. For example, if two transactions are trying to update the same data at the same time, one of them might overwrite the changes made by the other, resulting in data inconsistency or loss. Similarly, if one transaction reads data that another transaction has not yet committed, it might see incorrect or incomplete data, leading to errors or incorrect results. To prevent these problems, database systems use various mechanisms to control the concurrency of transactions, such as locking, timestamps, snapshots, or multiversioning.</p>
<p>However, achieving perfect isolation is not always possible or desirable, because it comes at a cost of performance and scalability. For example, locking a data item for a long time might prevent other transactions from accessing it, causing delays or deadlocks. Executing the transactions in a serial manner will provide the highest level of isolation, but at the same time will provide very poor throughput. Therefore, database systems allow users to choose different levels of isolation for their transactions, depending on their needs and preferences. The SQL standard defines four levels of isolation: <code>read uncommitted, read committed, repeatable read, and serializable</code>. Each level has different guarantees and trade-offs regarding the visibility and effects of concurrent transactions.</p>
<h3 id="what-are-the-four-standard-isolation-levels">What are the four standard isolation levels?</h3>
<p>The four standard isolation levels are defined by the following phenomena that might occur when a transaction reads data that another transaction might have updated:</p>
<p><img src="/images/blogs/database_isolation_levels/TrasactionsIsolationsLevels.svg" alt="Database Isolation levels and anomalies"></p>
<ul>
<li><strong>Dirty read:</strong> A dirty read occurs when a transaction reads data that has not yet been committed by another transaction. For example, if transaction T1 updates a row and leaves it uncommitted, and transaction T2 reads the same row before T1 commits or rolls back, then T2 has performed a dirty read. If T1 rolls back the change, T2 will have read data that is considered never to have existed.</li>
<li><strong>Non-repeatable read:</strong> A non-repeatable read occurs when a transaction reads the same row twice and gets a different value each time. For example, if transaction T1 reads a row, and then transaction T2 updates or deletes the same row and commits, and then T1 reads the same row again, then T1 has performed a non-repeatable read. The value that T1 read the first time is no longer valid.</li>
<li><strong>Phantom read:</strong> A phantom read occurs when two identical queries are executed by a transaction, but the rows retrieved by the two queries are different. For example, if transaction T1 retrieves a set of rows that satisfy some search criteria, and then transaction T2 inserts or deletes some rows that match the same criteria and commits, and then T1 executes the same query again,
then T1 has performed a phantom read. The set of rows that T1 retrieved the first time is no longer valid.</li>
</ul>
<p>Based on these phenomena, the four isolation levels are:</p>
<ul>
<li><strong>Read uncommitted</strong>: This is the lowest isolation level. In this level, a transaction may read uncommitted changes made by other transactions,
thereby allowing dirty reads. This level does not prevent any of the concurrency problems mentioned above,
but it provides the highest level of performance and concurrency,
as transactions do not need to acquire any locks on the data they access.</li>
<li><strong>Read committed</strong>: This isolation level guarantees that any data read by a transaction has been committed at the moment it is read.
Thus it prevents dirty reads,
but it does not prevent non-repeatable reads or phantom reads.
This level is achieved by holding a shared lock on the data item until it is read,
and then releasing it immediately after reading.
This allows other transactions to update or delete the data item after it has been read by another transaction.</li>
<li><strong>Repeatable read</strong>: This isolation level guarantees that any data read by a transaction will not change during the duration of the transaction.
Thus it prevents dirty reads and non-repeatable reads,
but it does not prevent phantom reads.
This level is achieved by holding a shared lock on the data item until the end of the transaction,
preventing other transactions from updating or deleting it.
However,
other transactions can still insert new rows that match the search criteria of another transaction,
causing phantom reads.</li>
<li><strong>Serializable</strong>: This is the highest isolation level. A serializable execution is equivalent to a serial execution, where transactions are executed one after another, without any concurrency. Thus it prevents all the concurrency problems mentioned above, but it also requires the most system resources and reduces the concurrency and scalability of the system. This level is achieved by using various techniques, such as locking, timestamps, or snapshot isolation, to ensure that transactions do not conflict with each other.</li>
</ul>
<p>What are the pros and cons of each isolation level?</p>
<p>Each isolation level has its own advantages and disadvantages, depending on the application requirements and expectations. Here are some general pros and cons of each level:</p>
<ul>
<li><strong>Read uncommitted</strong>: The main advantage of this level is that it provides the highest performance and concurrency, as transactions do not need to wait for locks or check for conflicts. The main disadvantage is that it allows dirty reads, which might cause errors or inconsistencies in the application logic or output. This level is suitable for applications that do not care about data accuracy or consistency, such as analytics or reporting.</li>
<li><strong>Read committed</strong>: The main advantage of this level is that it prevents dirty reads, which improves data accuracy and consistency. The main disadvantage is that it allows non-repeatable reads and phantom reads, which might cause errors or inconsistencies in the application logic or output. This level is suitable for applications that can tolerate some degree of inconsistency, such as online shopping or social media.</li>
<li><strong>Repeatable read</strong>: The main advantage of this level is that it prevents dirty reads and non-repeatable reads, which improves data accuracy and consistency. The main disadvantage is that it allows phantom reads, which might cause errors or inconsistencies in the application logic or output. This level is suitable for applications that need a consistent view of the data, such as banking or accounting.</li>
<li><strong>Serializable</strong>: The main advantage of this level is that it prevents all the concurrency problems, which ensures data accuracy and consistency. The main disadvantage is that it reduces performance and concurrency, as transactions need to wait for locks or check for conflicts. This level is suitable for applications that need the highest level of data integrity and correctness, such as financial transactions or inventory management.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>In this blog post, I have explained what database isolation levels are, why they are important, and how they affect the performance and correctness of concurrent transactions. I have also described each of the four standard isolation levels defined by SQL, and discussed their pros and cons. I hope you have found this post informative and useful. If you have any questions or feedback, please feel free to leave a comment below. Thank you for reading!</p>

    </div>
</div>

            </main>
        </div>


        <footer class="footer">
    
        <span>
            © 2023 The Dev Diary, Built with
            <a href="https://gohugo.io" class="footerLink">Hugo</a> 
        </span>
    
</footer>
    </div>

</body>

</html>