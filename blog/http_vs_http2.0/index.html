<!DOCTYPE html>
<html lang="en-us">

<head>
    <title>
HTTP vs HTTP 2.0 | The Dev Diary
</title>

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta name="generator" content="Hugo 0.110.0">


<link rel="canonical" href="https://thedevdiary.me/blog/http_vs_http2.0/" >
<link href="/sass/main.min.246424037d4ce4c9ef4936a2bf7fb7d3317ebc6810bc67415c661f85231c98f0.css" rel="stylesheet">



</head>

<body>

    <div class="flexWrapper">
        <header class="headerWrapper">
    <div class="header">
        <div>
            <a href="https://thedevdiary.me/">
                <span class="terminal">dev@diary ~ $</span>
            </a>
        </div>
        <input class="side-menu" type="checkbox" id="side-menu">
        <label class="hamb" for="side-menu"><span class="hamb-line"></span></label>
        <nav class="headerLinks">
            <ul>
                
                <li>
                    <a href="https://thedevdiary.me/about" title="" >
                        ~/about</a>
                </li>
                
                <li>
                    <a href="https://thedevdiary.me/blog/" title="" >
                        ~/blog</a>
                </li>
                
                <li>
                    <a href="https://thedevdiary.me/bookshelf" title="" >
                        ~/bookshelf</a>
                </li>
                
            </ul>
        </nav>
    </div>
</header>


        <div class="content">
            <main class="main">
                
<div class="postWrapper">
    <h1>HTTP vs HTTP 2.0</h1>
    <hr>
    
    <section class="postMetadata">
        <dl>
            
                
<dt>tags</dt>
<dd><span></span>
    <a href="/tags/http/">#http</a><span></span>
    <a href="/tags/backend/">#backend</a></dd>
            
            
            
            
                <dt>published</dt>
                
                <dd><time datetime="2023-02-05">February 5, 2023</time></dd>
            
            
        </dl>
    </section>
    
    <div class="postBody">
        <h2 id="what-is-http">What is HttP?</h2>
<p>HTTP, or Hypertext Transfer Protocol, is an application-layer protocol for transmitting hypermedia documents, such as HTML. It is the foundation of any data exchange on the Web and it is a client-server protocol, which means requests are initiated by the recipient, usually the Web browser .</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="evolution-of-http">Evolution of HTTP</h2>
<p>The Hypertext Transfer Protocol (HTTP) has evolved over time to improve performance, security, and features. Here is a brief overview of the evolution of HTTP:</p>
<ul>
<li><strong>HTTP/0.9</strong>: The first version of HTTP, released in 1991. It was a very simple protocol that only supported the GET - method and did not support persistent connections.</li>
<li><strong>HTTP/1.0</strong>: The second version of HTTP, released in 1996. It added support for more methods, such as POST, PUT, and DELETE, and it also supported persistent connections.</li>
<li><strong>HTTP/1.1</strong>: The third version of HTTP, released in 1997. It made a number of improvements to the protocol, including support for caching, pipelining, and compression.</li>
<li><strong>HTTP/2</strong>: The fourth version of HTTP, released in 2015. It is a major revision of the protocol that introduces a number of new features, such as multiplexing, header compression, and server push.</li>
<li><strong>HTTP/3</strong>: The fifth version of HTTP, still in development. It is designed to improve performance over lossy networks, such as the Internet.</li>
</ul>
<p>HTTP/2 is the most widely used version of HTTP today. It is supported by most web browsers and web servers. HTTP/3 is still in development, but it is expected to become more widely used in the future.</p>
<h2 id="how-http-works">How HTTP Works</h2>
<p>HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response. HTTP is a stateless protocol, meaning that the server does not keep any data (state) between two requests. However, some mechanisms, such as cookies and sessions, can be used to maintain state information across multiple requests .</p>
<p>A typical HTTP session consists of the following steps:</p>
<ul>
<li>The client sends an HTTP request message to the server. The request message consists of a request line (containing the method, URI, and protocol version), optional request headers (containing additional information about the request), and an optional message body (containing data or query parameters) .</li>
<li>The server receives the request and processes it. The server may perform various operations based on the request method, such as retrieving or modifying a resource, executing a script, or performing authentication or authorization. The server then sends an HTTP response message to the client. The response message consists of a status line (containing the protocol version, status code, and reason phrase), optional response headers (containing additional information about the response), and an optional message body (containing the requested resource or data) .</li>
<li>The client receives the response and processes it. The client may display the resource or data to the user, store it in a cache, or perform further actions based on the status code or headers. The client may also send additional requests to the server if needed .</li>
</ul>
<h2 id="what-are-the-problems-with-http">What are the problems with HTTP?</h2>
<p>HTTP is a widely used and successful protocol, but it also has some limitations and drawbacks that affect its performance and efficiency. Some of these problems are:</p>
<ul>
<li><strong>Head-of-line blocking</strong>: Head of line blocking (HOL) is a performance-limiting phenomenon that occurs when a line of packets is held up by the first packet. In HTTP/1.1, this problem can happen when multiple requests are sent over a single TCP connection using pipelining, but the server has to send the responses in the same order as the requests. This means that if the first response is slow or delayed, all the subsequent responses are blocked behind it. This problem is exacerbated by the fact that modern web applications often require multiple resources (such as images, scripts, stylesheets, etc.) to render a page, which means that multiple TCP connections have to be opened and closed for each page load. This also increases the overhead of TCP handshakes and slow start mechanisms.</li>
<li><strong>Redundant and verbose headers</strong>: As mentioned before, HTTP 1.1 sends redundant and verbose header fields in each request and response, which increases the size of the messages and wastes bandwidth. This problem is worsened by the fact that some header fields (such as cookies) can be very large and contain sensitive information that should not be exposed or tampered with.</li>
<li><strong>Unencrypted communication</strong>: HTTP 1.1 does not provide any encryption or security mechanisms by default, which means that all requests and responses are sent in plain text over the network, which exposes them to eavesdropping, interception, modification or injection attacks. To secure HTTP communication, HTTPS (HTTP over TLS) is often used, which adds encryption and authentication layers on top of HTTP. However, HTTPS also adds additional overhead and complexity to the protocol.</li>
</ul>
<p><img src="/images/blogs/http_vs_http2.0/multiplexing.svg" alt="http vs http2.0"></p>
<h2 id="what-is-http-20">What is HTTP 2.0?</h2>
<p>HTTP 2.0 is a major revision of HTTP that was derived from an experimental protocol called SPDY, originally developed by Google. HTTP 2.0 was developed by the HTTP Working Group of the Internet Engineering Task Force (IETF) and published as RFC 7540 in May 2015.</p>
<p>HTTP 2.0 maintains high-level compatibility with HTTP 1.1, meaning that it uses the same methods, status codes, URIs and most header fields as HTTP 1.1. However, it introduces significant changes in how the data is framed and transported between the client and the server.</p>
<h3 id="the-main-features-of-http-20-are">The main features of HTTP 2.0 are:</h3>
<ul>
<li>
<p>Binary framing layer: As opposed to HTTP 1.1, which keeps all requests and responses in plain text format, HTTP 2.0 uses a binary framing layer to encapsulate all messages in binary format, while still maintaining HTTP semantics. The binary framing layer divides each message into smaller units called frames, which have a fixed length header and a variable length payload. Each frame belongs to a stream, which is a bidirectional flow of frames between the client and the server that share a common identifier. Each stream has a priority and can be dependent on another stream.</p>
</li>
<li>
<p>Multiplexing: Multiplexing is the ability to send and receive multiple requests and responses over a single connection, without waiting for each one to finish before starting the next one. This reduces the latency and overhead of establishing and closing multiple connections, and allows the browser and the server to use the network more efficiently.</p>
<p>In HTTP/2, each request and response pair is associated with a unique identifier, called a <strong>stream ID</strong>, and is divided into smaller units, called <strong>frames</strong>. Frames can be sent and received in any order, as long as they have the correct stream ID. This allows multiple requests and responses to be multiplexed over a single connection, without blocking each other.
It reduces the number of connections that need to be opened and maintained, which saves CPU and memory resources on both the browser and the server.
It also reduces the latency of transferring multiple resources, especially for small or dependent resources, which improves the page load time and user experience.</p>
</li>
<li>
<p>Header compression: Another problem of HTTP 1.1 is that it sends redundant and verbose header fields in each request and response, which increases the size of the messages and wastes bandwidth. To solve this problem, HTTP 2.0 uses a compression algorithm called HPACK to reduce the size of the header fields. HPACK uses a static table of common header fields and a dynamic table of header fields that are updated during the session. HPACK also employs Huffman encoding to further compress the header values.</p>
</li>
<li>
<p>Server push: A feature of HTTP 2.0 that allows the server to send resources to the client before the client requests them, which can improve the performance of web applications. For example, if the client requests an HTML document that contains references to several images, the server can push those images to the client along with the HTML document, without waiting for the client to request them. This can reduce the number of round trips and save bandwidth. The client can accept or reject the pushed resources based on its cache or preferences.</p>
</li>
<li>
<p>Stream prioritization: A feature of HTTP 2.0 that allows the client to indicate the relative priority of each stream, which can help the server to allocate resources and optimize bandwidth. For example, if the client requests an HTML document that contains references to several images and scripts, the client can assign higher priority to the scripts than to the images, so that the scripts can be executed faster and render the page sooner. The server can use this information to prioritize the delivery of the frames according to their stream priority and dependency.</p>
</li>
</ul>
<h2 id="how-does-http-20-solve-these-problems">How does HTTP 2.0 solve these problems?</h2>
<ul>
<li>
<p><strong>Head-of-line blocking</strong>: HTTP/2 solves this problem by introducing <strong>multiplexing</strong>, which allows multiple requests and responses to be sent over the same connection <strong>concurrently</strong> and <strong>independently</strong>. Multiplexing uses binary framing to split the HTTP messages into smaller frames that can be interleaved and reassembled at the end points. This way, the server can send the responses as soon as they are ready, without waiting for the previous ones to complete. Multiplexing also reduces the overhead of opening and closing multiple connections, and enables more efficient use of network resources.</p>
<p>However, HTTP/2 still suffers from HOL blocking at the TCP layer, because TCP is a reliable and ordered protocol that requires the packets to be delivered in sequence. If a packet is lost or corrupted, all the subsequent packets have to wait until the retransmission of the missing packet. This affects all the HTTP/2 streams that share the same TCP connection. To overcome this limitation, a new protocol called QUIC (Quick UDP Internet Connections) is being developed, which implements a TCP-like protocol over UDP, where each stream is independent and can recover from packet loss without blocking other streams.</p>
</li>
<li>
<p><strong>Stream prioritization</strong>: It is a feature of HTTP/2 that allows clients and servers to indicate the relative importance of different resources, such as HTML, CSS, JavaScript, images, etc. By using stream prioritization, clients and servers can optimize the use of the underlying TCP connection and improve the perceived performance of web pages.</p>
<p>HTTP/2 is a binary protocol that multiplexes multiple requests and responses over a single TCP connection. Each request and response is divided into frames, which are assigned to a stream. A stream is a bidirectional flow of frames that share a common identifier and have some associated state. Each stream can carry one or more messages, which are logical sequences of frames that represent a single request or response.</p>
<p>Stream prioritization is implemented by using two types of frames: HEADERS and PRIORITY. The HEADERS frame contains the HTTP headers of a request or response, and optionally some priority information. The PRIORITY frame can be sent at any time to update the priority information of a stream. The priority information consists of three fields:</p>
<ul>
<li><strong>Stream dependency</strong>: an identifier of another stream that this stream depends on. This creates a dependency tree of streams, where the root stream has no dependency and the leaf streams have no dependents.</li>
<li>Weight: an integer between 1 and 256 that indicates the relative weight of this stream compared to its siblings. Higher weights are more important.</li>
<li><strong>Exclusive</strong>: a boolean flag that indicates whether this stream should be the only dependent of its parent stream.</li>
</ul>
<p>The dependency tree and the weights are used by the server to determine the order and proportion of data to send for each stream. The server should try to satisfy the dependencies of higher-priority streams before lower-priority ones, and allocate more bandwidth to higher-weight streams than lower-weight ones. The exclusive flag can be used to rearrange the dependency tree and give a stream higher or lower priority.</p>
<p>For example, suppose a client requests a web page that consists of an HTML document, a CSS file, a JavaScript file, and two images. The client can use stream prioritization to indicate that the HTML document is the most important resource, followed by the CSS file, then the JavaScript file, and finally the images. The client can also indicate that the CSS file depends on the HTML document, and the JavaScript file depends on both the HTML document and the CSS file. The client can assign different weights to each resource according to their size or importance.</p>
</li>
<li>
<p><strong>Header compression</strong>: It is a technique that reduces the size of HTTP headers, which are used to exchange information between clients and servers. HTTP headers can contain many fields, such as cookies, user-agent, content-type, etc., that are often repeated across multiple requests and responses. This can result in a lot of overhead and slow down the web performance, especially on mobile devices.</p>
<p>HTTP 2.0 introduces a new header compression algorithm, called HPACK, that is designed to address this problem. HPACK uses three methods of compression:</p>
<ul>
<li><strong>Static table</strong>: A predefined list of common header fields and values that are assigned fixed indexes. For example, the field :method with the value <code>GET</code> has the index 2.</li>
<li><strong>Dynamic table</strong>: A list of header fields and values that are dynamically updated based on the headers seen in previous requests and responses. The dynamic table is maintained by both the client and the server and synchronized using index values.</li>
<li><strong>Huffman encoding</strong>: A variable-length coding scheme that assigns shorter codes to more frequent symbols and longer codes to less frequent symbols. For example, the ASCII character &rsquo;e&rsquo; has the code <code>1110</code>, while the character <code>z</code> has the code <code>101011</code>.</li>
</ul>
<p>Using these methods, HPACK can compress headers by eliminating redundancy, using shorter representations, and exploiting the context of previous headers. For example, if a client sends a request with the header <code>:method: GET</code>, it can use the index 2 to refer to it. If the server responds with the same header, it can omit it entirely, since it is already in the dynamic table. If a header field or value is not in the static or dynamic table, it can be encoded using Huffman codes.</p>
<p>Header compression in HTTP 2.0 can significantly improve the web performance by reducing the bandwidth usage, latency, and packet loss. It can also enhance the security and privacy of HTTP communication by preventing attacks like CRIME that exploit the compression of sensitive data.</p>
</li>
<li>
<p>HTTP/2 is the latest version of the HTTP protocol that powers the web. It offers many benefits, such as faster page loading, server push, and multiplexing. But how does encryption work in HTTP/2?</p>
<p>HTTP/2 can be used with or without encryption, but most browsers only support it over TLS, the protocol that secures HTTPS connections. To use HTTP/2 with encryption, servers and clients need to negotiate the use of the protocol using a mechanism called ALPN (Application-Layer Protocol Negotiation). ALPN allows servers to indicate which protocols they support, and clients to choose the best one for them. For example, a server can say that it supports HTTP/1.1, HTTP/2, and SPDY, and a client can pick HTTP/2 as the preferred option.</p>
<p>When a client connects to a server using TLS, it sends a list of supported protocols in the ClientHello message. The server then responds with the selected protocol in the ServerHello message. The rest of the TLS handshake proceeds as usual, and the server presents a certificate for the domain signed by a trusted certificate authority. The client validates the certificate and establishes a secure connection. Then, the client and server can exchange HTTP/2 messages over that connection.</p>
<p>However, not all websites use HTTPS or have valid certificates. Some websites still use HTTP, which is unencrypted and vulnerable to eavesdropping and tampering. To enable HTTP/2 for these websites, there is another mechanism called Opportunistic Encryption. Opportunistic Encryption allows servers to tell clients that they can accept HTTP requests over an encrypted connection, even if they don&rsquo;t have a valid certificate.</p>
<p>To use Opportunistic Encryption, servers need to send an Alternative Service header to clients, indicating that they support HTTP/2 (or SPDY) over TLS on port 443. For example:</p>
<p>Alt-Svc: h2=&quot;:443&quot;; ma=60</p>
<p>This header tells the client that the website can be accessed using HTTP/2 over TLS on port 443 for 60 seconds. The client then tries to connect to the server using TLS on port 443, where the server presents a certificate for the domain. The client does not validate the certificate, but only checks that it matches the domain name. If the connection succeeds, the client sends HTTP requests over that connection using HTTP/2. However, these requests are not considered HTTPS requests, but HTTP requests over an encrypted connection. The client does not show any security indicator in the address bar for these requests.</p>
<p>Opportunistic Encryption provides some level of security and performance benefits for websites that have not yet migrated to HTTPS. However, it is not a substitute for HTTPS, as it does not guarantee authenticity or integrity of the connection. Opportunistic Encryption is only supported by some browsers, such as Firefox, and is enabled by default for CloudFlare customers.</p>
</li>
</ul>

    </div>
</div>

            </main>
        </div>


        <footer class="footer">
    
        <span>
            © 2023 The Dev Diary, Built with
            <a href="https://gohugo.io" class="footerLink">Hugo</a> 
        </span>
    
</footer>
    </div>

</body>

</html>